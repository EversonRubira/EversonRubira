name: Update README with Recent Projects

on:
  schedule:
    # Runs daily at 00:00 UTC (01:00 Portugal time)
    - cron: '0 0 * * *'
  workflow_dispatch: # Allows manual execution
  push:
    branches: [main]

jobs:
  update-readme:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Update README with recent projects
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = 'EversonRubira';

            // â”€â”€ Dependency maps per ecosystem â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            // pom.xml (Java/Kotlin + Maven)
            const POM_MAP = [
              { pattern: /spring-boot/i,           label: 'Spring Boot'      },
              { pattern: /spring-security/i,        label: 'Spring Security'  },
              { pattern: /spring-data-jpa/i,        label: 'Spring Data JPA'  },
              { pattern: /spring-data-mongodb/i,    label: 'MongoDB'          },
              { pattern: /spring-data-redis/i,      label: 'Redis'            },
              { pattern: /spring-data-elasticsearch/i, label: 'Elasticsearch' },
              { pattern: /spring-cloud/i,           label: 'Spring Cloud'     },
              { pattern: /mysql-connector|com\.mysql/i, label: 'MySQL'        },
              { pattern: /mongodb-driver/i,         label: 'MongoDB'          },
              { pattern: /postgresql/i,             label: 'PostgreSQL'       },
              { pattern: /h2/i,                     label: 'H2'               },
              { pattern: /jedis|lettuce/i,          label: 'Redis'            },
              { pattern: /kafka/i,                  label: 'Kafka'            },
              { pattern: /rabbitmq|amqp/i,          label: 'RabbitMQ'         },
              { pattern: /flyway/i,                 label: 'Flyway'           },
              { pattern: /liquibase/i,              label: 'Liquibase'        },
              { pattern: /springdoc|swagger/i,      label: 'Swagger'          },
              { pattern: /jjwt|java-jwt/i,          label: 'JWT'              },
              { pattern: /mapstruct/i,              label: 'MapStruct'        },
              { pattern: /lombok/i,                 label: 'Lombok'           },
              { pattern: /quarkus/i,                label: 'Quarkus'          },
              { pattern: /micronaut/i,              label: 'Micronaut'        },
              { pattern: /kotlin/i,                 label: 'Kotlin'           },
            ];

            // build.gradle or build.gradle.kts (Gradle)
            const GRADLE_MAP = [
              { pattern: /spring.boot/i,            label: 'Spring Boot'      },
              { pattern: /spring.security/i,        label: 'Spring Security'  },
              { pattern: /spring.data.jpa/i,        label: 'Spring Data JPA'  },
              { pattern: /spring.data.mongodb/i,    label: 'MongoDB'          },
              { pattern: /spring.data.redis/i,      label: 'Redis'            },
              { pattern: /spring.cloud/i,           label: 'Spring Cloud'     },
              { pattern: /mysql/i,                  label: 'MySQL'            },
              { pattern: /mongodb/i,                label: 'MongoDB'          },
              { pattern: /postgresql/i,             label: 'PostgreSQL'       },
              { pattern: /kafka/i,                  label: 'Kafka'            },
              { pattern: /rabbitmq/i,               label: 'RabbitMQ'         },
              { pattern: /kotlin/i,                 label: 'Kotlin'           },
              { pattern: /quarkus/i,                label: 'Quarkus'          },
              { pattern: /micronaut/i,              label: 'Micronaut'        },
              { pattern: /jjwt|java-jwt/i,          label: 'JWT'              },
            ];

            // package.json (Node.js / frontend)
            const NPM_MAP = [
              { pattern: /\"express\"/i,            label: 'Express'          },
              { pattern: /\"fastify\"/i,            label: 'Fastify'          },
              { pattern: /\"@nestjs\/core\"/i,      label: 'NestJS'           },
              { pattern: /\"koa\"/i,                label: 'Koa'              },
              { pattern: /\"hapi\"/i,               label: 'Hapi'             },
              { pattern: /\"react\"/i,              label: 'React'            },
              { pattern: /\"next\"/i,               label: 'Next.js'          },
              { pattern: /\"vue\"/i,                label: 'Vue.js'           },
              { pattern: /\"nuxt\"/i,               label: 'Nuxt.js'          },
              { pattern: /\"@angular\/core\"/i,     label: 'Angular'          },
              { pattern: /\"svelte\"/i,             label: 'Svelte'           },
              { pattern: /\"mongoose\"/i,           label: 'MongoDB'          },
              { pattern: /\"mongodb\"/i,            label: 'MongoDB'          },
              { pattern: /\"pg\"/i,                 label: 'PostgreSQL'       },
              { pattern: /\"mysql2?\"/i,            label: 'MySQL'            },
              { pattern: /\"redis\"/i,              label: 'Redis'            },
              { pattern: /\"ioredis\"/i,            label: 'Redis'            },
              { pattern: /\"prisma\"/i,             label: 'Prisma'           },
              { pattern: /\"typeorm\"/i,            label: 'TypeORM'          },
              { pattern: /\"sequelize\"/i,          label: 'Sequelize'        },
              { pattern: /\"drizzle-orm\"/i,        label: 'Drizzle'          },
              { pattern: /\"graphql\"/i,            label: 'GraphQL'          },
              { pattern: /\"socket\.io\"/i,         label: 'Socket.io'        },
              { pattern: /\"jsonwebtoken\"/i,       label: 'JWT'              },
              { pattern: /\"typescript\"/i,         label: 'TypeScript'       },
            ];

            // requirements.txt or pyproject.toml (Python)
            const PYTHON_MAP = [
              { pattern: /django/i,                 label: 'Django'           },
              { pattern: /flask/i,                  label: 'Flask'            },
              { pattern: /fastapi/i,                label: 'FastAPI'          },
              { pattern: /tornado/i,                label: 'Tornado'          },
              { pattern: /aiohttp/i,                label: 'aiohttp'          },
              { pattern: /sqlalchemy/i,             label: 'SQLAlchemy'       },
              { pattern: /pymongo/i,                label: 'MongoDB'          },
              { pattern: /motor/i,                  label: 'MongoDB'          },
              { pattern: /psycopg2/i,               label: 'PostgreSQL'       },
              { pattern: /mysql.connector|pymysql/i,label: 'MySQL'            },
              { pattern: /redis/i,                  label: 'Redis'            },
              { pattern: /celery/i,                 label: 'Celery'           },
              { pattern: /pydantic/i,               label: 'Pydantic'         },
              { pattern: /alembic/i,                label: 'Alembic'          },
              { pattern: /tortoise/i,               label: 'Tortoise ORM'     },
            ];

            // go.mod (Go)
            const GO_MAP = [
              { pattern: /gin-gonic\/gin/i,         label: 'Gin'              },
              { pattern: /labstack\/echo/i,          label: 'Echo'             },
              { pattern: /gofiber\/fiber/i,          label: 'Fiber'            },
              { pattern: /chi/i,                    label: 'Chi'              },
              { pattern: /gorilla\/mux/i,            label: 'Gorilla Mux'     },
              { pattern: /gorm/i,                   label: 'GORM'             },
              { pattern: /mongo-driver/i,            label: 'MongoDB'          },
              { pattern: /go-redis/i,                label: 'Redis'            },
              { pattern: /kafka/i,                  label: 'Kafka'            },
              { pattern: /rabbitmq/i,               label: 'RabbitMQ'         },
              { pattern: /grpc/i,                   label: 'gRPC'             },
              { pattern: /pgx|pq/i,                 label: 'PostgreSQL'       },
              { pattern: /go-sql-driver\/mysql/i,   label: 'MySQL'            },
            ];

            // Languages considered "backend" â€” markup is hidden when these exist
            const BACKEND_LANGUAGES = new Set([
              'Java', 'Python', 'Go', 'Rust', 'C', 'C++', 'C#',
              'TypeScript', 'JavaScript', 'Kotlin', 'Scala', 'Ruby', 'PHP'
            ]);
            const MARKUP_LANGUAGES = new Set(['HTML', 'CSS', 'SCSS', 'Less']);

            // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            // Fetch a file from a repo, return its text content or null
            async function fetchFile(repoName, path) {
              try {
                const { data } = await github.rest.repos.getContent({ owner, repo: repoName, path });
                return Buffer.from(data.content, 'base64').toString('utf-8');
              } catch {
                return null;
              }
            }

            // Apply a pattern map against file content; return matched labels (deduped)
            function matchLabels(content, map) {
              const found = [];
              for (const { pattern, label } of map) {
                if (pattern.test(content) && !found.includes(label)) found.push(label);
              }
              return found;
            }

            // Detect tech stack by reading build/manifest files; returns null if nothing found
            async function getTechStackFromFiles(repoName, primaryLanguage) {
              // 1. Java / Kotlin â€” Maven
              const pom = await fetchFile(repoName, 'pom.xml');
              if (pom) {
                const lang = /kotlin/i.test(pom) ? 'Kotlin' : 'Java';
                const deps = matchLabels(pom, POM_MAP).filter(l => l !== 'Kotlin');
                console.log(`   âœ… pom.xml detected (${lang})`);
                return [lang, ...deps].join(', ');
              }

              // 2. Java / Kotlin â€” Gradle
              const gradle = await fetchFile(repoName, 'build.gradle')
                          ?? await fetchFile(repoName, 'build.gradle.kts');
              if (gradle) {
                const lang = /kotlin/i.test(gradle) || repoName.endsWith('.kts') ? 'Kotlin' : 'Java';
                const deps = matchLabels(gradle, GRADLE_MAP).filter(l => l !== 'Kotlin');
                console.log(`   âœ… build.gradle detected (${lang})`);
                return [lang, ...deps].join(', ');
              }

              // 3. Node.js / Frontend â€” package.json
              const pkg = await fetchFile(repoName, 'package.json');
              if (pkg) {
                let pkgJson;
                try { pkgJson = JSON.parse(pkg); } catch { pkgJson = {}; }
                const allDeps = JSON.stringify({
                  ...pkgJson.dependencies,
                  ...pkgJson.devDependencies
                });
                const hasTS = /"typescript"/.test(allDeps);
                const lang  = hasTS ? 'TypeScript' : 'JavaScript';
                const deps  = matchLabels(allDeps, NPM_MAP).filter(l => l !== 'TypeScript');
                console.log(`   âœ… package.json detected (${lang})`);
                return [lang, ...deps].join(', ');
              }

              // 4. Python â€” requirements.txt or pyproject.toml
              const requirements = await fetchFile(repoName, 'requirements.txt')
                                ?? await fetchFile(repoName, 'pyproject.toml');
              if (requirements) {
                const deps = matchLabels(requirements, PYTHON_MAP);
                console.log(`   âœ… Python manifest detected`);
                return ['Python', ...deps].join(', ');
              }

              // 5. Go â€” go.mod
              const goMod = await fetchFile(repoName, 'go.mod');
              if (goMod) {
                const deps = matchLabels(goMod, GO_MAP);
                console.log(`   âœ… go.mod detected`);
                return ['Go', ...deps].join(', ');
              }

              return null; // no recognized build file
            }

            // Fallback: GitHub language detection with markup filter
            async function getTechStackFromLanguages(repoName, repoLanguage) {
              const { data: languages } = await github.rest.repos.listLanguages({
                owner, repo: repoName
              });
              const detected  = Object.keys(languages);
              const hasBackend = detected.some(l => BACKEND_LANGUAGES.has(l));
              const filtered  = hasBackend
                ? detected.filter(l => !MARKUP_LANGUAGES.has(l)).slice(0, 3)
                : detected.slice(0, 3);
              console.log(`   â„¹ï¸ Fallback to language detection`);
              return filtered.join(', ') || repoLanguage || 'N/A';
            }

            // â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            console.log('ğŸ” Fetching repositories...');

            const { data: repos } = await github.rest.repos.listForUser({
              username: owner,
              sort: 'pushed',
              direction: 'desc',
              per_page: 100
            });

            console.log(`ğŸ“¦ Total repositories found: ${repos.length}`);

            const recentRepos = repos
              .filter(repo => !repo.fork && repo.name !== 'EversonRubira')
              .slice(0, 4);

            console.log('âœ… Selected repositories:');
            recentRepos.forEach(repo => console.log(`   - ${repo.name}`));

            let content = '';

            for (const repo of recentRepos) {
              console.log(`\nğŸ“ Processing: ${repo.name}`);

              const fileStack = await getTechStackFromFiles(repo.name, repo.language);
              const techStack = fileStack ?? await getTechStackFromLanguages(repo.name, repo.language);
              console.log(`   Tech Stack: ${techStack}`);

              const lastPushDate  = new Date(repo.pushed_at);
              const formattedDate = lastPushDate.toLocaleDateString('en-US', {
                day: 'numeric', month: 'short', year: 'numeric'
              });

              let lastCommitMsg = '';
              try {
                const { data: commits } = await github.rest.repos.listCommits({
                  owner, repo: repo.name, per_page: 1
                });
                if (commits.length > 0) {
                  lastCommitMsg = commits[0].commit.message.split('\n')[0];
                  if (lastCommitMsg.length > 60) lastCommitMsg = lastCommitMsg.substring(0, 57) + '...';
                }
              } catch (error) {
                console.log(`   âš ï¸ Could not fetch commits: ${error.message}`);
              }

              content += `### ğŸ”¹ [${repo.name}](${repo.html_url})`;
              if (repo.stargazers_count > 0) content += ` â­ ${repo.stargazers_count}`;
              content += `\n`;

              const description = repo.description || 'Backend development project';
              content += `${description}\n\n`;

              content += `**Tech Stack:** ${techStack}`;
              if (repo.forks_count > 0) content += ` â€¢ **Forks:** ${repo.forks_count}`;
              content += `  \n`;

              content += `**Last updated:** ${formattedDate}`;
              if (lastCommitMsg) content += `  \nğŸ’¬ _"${lastCommitMsg}"_`;

              content += `\n\n---\n\n`;
            }

            // â”€â”€ Update README â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            console.log('\nğŸ“– Reading current README...');

            const { data: readmeData } = await github.rest.repos.getContent({
              owner, repo: 'EversonRubira', path: 'README.md'
            });

            const readme      = Buffer.from(readmeData.content, 'base64').toString('utf-8');
            const startMarker = '<!-- RECENT_PROJECTS:START -->';
            const endMarker   = '<!-- RECENT_PROJECTS:END -->';
            const regex       = new RegExp(`${startMarker}[\\s\\S]*?${endMarker}`, 'g');

            if (!regex.test(readme)) {
              console.error('âŒ Markers not found in README!');
              core.setFailed('Markers not found');
              return;
            }

            const newReadme = readme.replace(regex, `${startMarker}\n${content}${endMarker}`);

            if (readme === newReadme) {
              console.log('âœ¨ No changes detected. README is already up to date!');
              return;
            }

            console.log('ğŸ’¾ Updating README...');

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo: 'EversonRubira',
              path: 'README.md',
              message: 'ğŸ¤– Auto-update: Recent projects updated',
              content: Buffer.from(newReadme).toString('base64'),
              sha: readmeData.sha
            });

            console.log('âœ… README updated successfully!');
