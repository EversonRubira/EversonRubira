name: Update README with Recent Projects

on:
  schedule:
    # Runs daily at 00:00 UTC (01:00 Portugal time)
    - cron: '0 0 * * *'
  workflow_dispatch: # Allows manual execution
  push:
    branches: [main]

jobs:
  update-readme:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Update README with recent projects
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = 'EversonRubira';

            // Maps artifactId/groupId fragments found in pom.xml to display names
            const POM_DEPENDENCY_MAP = [
              { pattern: /spring-boot/i,              label: 'Spring Boot'      },
              { pattern: /spring-security/i,          label: 'Spring Security'  },
              { pattern: /spring-data-jpa/i,          label: 'Spring Data JPA'  },
              { pattern: /mysql-connector/i,           label: 'MySQL'            },
              { pattern: /com\.mysql/i,                label: 'MySQL'            },
              { pattern: /spring-data-mongodb/i,       label: 'MongoDB'          },
              { pattern: /mongodb-driver/i,            label: 'MongoDB'          },
              { pattern: /postgresql/i,                label: 'PostgreSQL'       },
              { pattern: /spring-data-redis/i,         label: 'Redis'            },
              { pattern: /jedis/i,                     label: 'Redis'            },
              { pattern: /kafka/i,                     label: 'Kafka'            },
              { pattern: /rabbitmq|amqp/i,             label: 'RabbitMQ'         },
              { pattern: /flyway/i,                    label: 'Flyway'           },
              { pattern: /liquibase/i,                 label: 'Liquibase'        },
              { pattern: /springdoc|swagger/i,         label: 'Swagger'          },
              { pattern: /jjwt|java-jwt/i,             label: 'JWT'              },
              { pattern: /docker/i,                    label: 'Docker'           },
            ];

            // Languages considered backend â€” markup is hidden when these are present
            const BACKEND_LANGUAGES = new Set([
              'Java', 'Python', 'Go', 'Rust', 'C', 'C++', 'C#',
              'TypeScript', 'JavaScript', 'Kotlin', 'Scala', 'Ruby', 'PHP'
            ]);

            const MARKUP_LANGUAGES = new Set(['HTML', 'CSS', 'SCSS', 'Less']);

            // Try to extract tech stack from pom.xml; returns null if not found
            async function getTechStackFromPom(repoName) {
              try {
                const { data: pomData } = await github.rest.repos.getContent({
                  owner,
                  repo: repoName,
                  path: 'pom.xml'
                });

                const pom = Buffer.from(pomData.content, 'base64').toString('utf-8');
                console.log(`   âœ… pom.xml found in ${repoName}`);

                // Detect primary language (always Java if pom.xml exists)
                const stack = ['Java'];

                // Extract all <artifactId> and <groupId> values from dependencies
                const artifactIds = [...pom.matchAll(/<artifactId>(.*?)<\/artifactId>/g)].map(m => m[1]);
                const groupIds    = [...pom.matchAll(/<groupId>(.*?)<\/groupId>/g)].map(m => m[1]);
                const allIds      = [...artifactIds, ...groupIds].join('\n');

                // Match against known patterns (deduplicated)
                for (const { pattern, label } of POM_DEPENDENCY_MAP) {
                  if (pattern.test(allIds) && !stack.includes(label)) {
                    stack.push(label);
                  }
                }

                return stack.join(', ');
              } catch (err) {
                // 404 = no pom.xml; any other error is also treated as "not found"
                console.log(`   â„¹ï¸ No pom.xml in ${repoName} â€” falling back to language detection`);
                return null;
              }
            }

            // Fallback: use GitHub language detection, filtering markup for backend projects
            async function getTechStackFromLanguages(repoName, repoLanguage) {
              const { data: languages } = await github.rest.repos.listLanguages({
                owner,
                repo: repoName
              });

              const detectedLangs = Object.keys(languages);
              const hasBackend = detectedLangs.some(l => BACKEND_LANGUAGES.has(l));

              const filtered = hasBackend
                ? detectedLangs.filter(l => !MARKUP_LANGUAGES.has(l)).slice(0, 3)
                : detectedLangs.slice(0, 3);

              return filtered.join(', ') || repoLanguage || 'N/A';
            }

            // â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            console.log('ğŸ” Fetching repositories...');

            const { data: repos } = await github.rest.repos.listForUser({
              username: owner,
              sort: 'pushed',
              direction: 'desc',
              per_page: 100
            });

            console.log(`ğŸ“¦ Total repositories found: ${repos.length}`);

            const recentRepos = repos
              .filter(repo => !repo.fork && repo.name !== 'EversonRubira')
              .slice(0, 4);

            console.log('âœ… Selected repositories:');
            recentRepos.forEach(repo => console.log(`   - ${repo.name}`));

            let content = '';

            for (const repo of recentRepos) {
              console.log(`\nğŸ“ Processing: ${repo.name}`);

              // 1. Try pom.xml first, fall back to language detection
              const pomStack  = await getTechStackFromPom(repo.name);
              const techStack = pomStack ?? await getTechStackFromLanguages(repo.name, repo.language);
              console.log(`   Tech Stack: ${techStack}`);

              // 2. Format date
              const lastPushDate = new Date(repo.pushed_at);
              const formattedDate = lastPushDate.toLocaleDateString('en-US', {
                day: 'numeric',
                month: 'short',
                year: 'numeric'
              });

              // 3. Last commit message
              let lastCommitMsg = '';
              try {
                const { data: commits } = await github.rest.repos.listCommits({
                  owner,
                  repo: repo.name,
                  per_page: 1
                });
                if (commits.length > 0) {
                  lastCommitMsg = commits[0].commit.message.split('\n')[0];
                  if (lastCommitMsg.length > 60) {
                    lastCommitMsg = lastCommitMsg.substring(0, 57) + '...';
                  }
                }
              } catch (error) {
                console.log(`   âš ï¸ Could not fetch commits: ${error.message}`);
              }

              // 4. Build markdown block
              content += `### ğŸ”¹ [${repo.name}](${repo.html_url})`;
              if (repo.stargazers_count > 0) content += ` â­ ${repo.stargazers_count}`;
              content += `\n`;

              const description = repo.description || 'Backend development project';
              content += `${description}\n\n`;

              content += `**Tech Stack:** ${techStack}`;
              if (repo.forks_count > 0) content += ` â€¢ **Forks:** ${repo.forks_count}`;
              content += `  \n`;

              content += `**Last updated:** ${formattedDate}`;
              if (lastCommitMsg) content += `  \nğŸ’¬ _"${lastCommitMsg}"_`;

              content += `\n\n---\n\n`;
            }

            // â”€â”€ Update README â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            console.log('\nğŸ“– Reading current README...');

            const { data: readmeData } = await github.rest.repos.getContent({
              owner,
              repo: 'EversonRubira',
              path: 'README.md'
            });

            const readme = Buffer.from(readmeData.content, 'base64').toString('utf-8');

            const startMarker = '<!-- RECENT_PROJECTS:START -->';
            const endMarker   = '<!-- RECENT_PROJECTS:END -->';
            const regex = new RegExp(`${startMarker}[\\s\\S]*?${endMarker}`, 'g');

            if (!regex.test(readme)) {
              console.error('âŒ Markers not found in README!');
              core.setFailed('Markers <!-- RECENT_PROJECTS:START --> and <!-- RECENT_PROJECTS:END --> not found');
              return;
            }

            const newReadme = readme.replace(
              regex,
              `${startMarker}\n${content}${endMarker}`
            );

            if (readme === newReadme) {
              console.log('âœ¨ No changes detected. README is already up to date!');
              return;
            }

            console.log('ğŸ’¾ Updating README...');

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo: 'EversonRubira',
              path: 'README.md',
              message: 'ğŸ¤– Auto-update: Recent projects updated',
              content: Buffer.from(newReadme).toString('base64'),
              sha: readmeData.sha
            });

            console.log('âœ… README updated successfully!');
